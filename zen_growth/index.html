<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zen Growth: Battle Royale</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #a8d8ea;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            pointer-events: none;
            text-shadow: 2px 2px 0px rgba(0, 0, 0, 0.1);
            z-index: 10;
        }

        h1 {
            margin: 0;
            font-size: 2rem;
            letter-spacing: 2px;
            font-weight: 900;
            -webkit-text-stroke: 1px black;
        }

        p {
            margin: 5px 0 0 0;
            font-size: 1.2rem;
            font-weight: bold;
            -webkit-text-stroke: 0.5px black;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.5rem;
            font-weight: bold;
            transition: opacity 0.5s;
            z-index: 20;
        }

        /* Speed Lines Overlay */
        #speed-lines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: repeating-conic-gradient(from 0deg,
                    transparent 0deg 10deg,
                    rgba(255, 255, 255, 0.1) 10deg 12deg);
            opacity: 0;
            transition: opacity 0.1s;
            mix-blend-mode: overlay;
            z-index: 5;
        }

        /* Vignette */
        #vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(circle, transparent 60%, rgba(0, 0, 0, 0.2) 100%);
            z-index: 4;
        }

        /* Start Overlay */
        #start-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            cursor: pointer;
            transition: opacity 0.5s;
            z-index: 30;
        }

        #start-overlay .content {
            text-align: center;
        }

        #start-overlay h1 {
            font-size: 4rem;
            margin-bottom: 20px;
            -webkit-text-stroke: 2px black;
        }

        #start-overlay p {
            font-size: 1.8rem;
            font-weight: bold;
            -webkit-text-stroke: 1px black;
            animation: pulse 2s infinite;
        }

        #game-over-overlay {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 40;
            color: white;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }

        #game-over-title {
            font-size: 5rem;
            color: #ff6b6b;
            -webkit-text-stroke: 3px black;
        }

        #leaderboard {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 10px;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            pointer-events: none;
            z-index: 10;
            min-width: 200px;
        }

        #leaderboard h3 {
            margin: 0 0 10px 0;
            text-align: center;
            font-size: 1.2rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 5px;
        }

        #leaderboard ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        #leaderboard li {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 1rem;
        }

        #leaderboard li.player {
            color: #ffd93d;
            font-weight: bold;
        }

        @keyframes pulse {
            0% {
                opacity: 0.5;
            }

            50% {
                opacity: 1;
            }

            100% {
                opacity: 0.5;
            }
        }
    </style>
    <!-- Load Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>

<body>
    <div id="loading">Loading Zen...</div>
    <div id="speed-lines"></div>
    <div id="vignette"></div>
    <div id="ui-layer">
        <h1>ZEN GROWTH</h1>
        <p>Size: <span id="score">1.0</span></p>
        <p>Alive: <span id="alive-count">10</span></p>
    </div>
    <div id="leaderboard">
        <h3>LEADERBOARD</h3>
        <ul id="leaderboard-list">
            <!-- Items injected via JS -->
        </ul>
    </div>
    <div id="canvas-container"></div>

    <div id="start-overlay">
        <div class="content">
            <h1>ZEN GROWTH</h1>
            <p>Click to Begin</p>
            <p style="font-size: 1rem; margin-top: 20px;">Mouse to Move • Hold Click to Sprint • Space to Dash</p>
            <p style="font-size: 1rem; margin-top: 5px;">WASD to Rotate Camera</p>
        </div>
    </div>

    <div id="game-over-overlay">
        <h1 id="game-over-title">GAME OVER</h1>
        <p>Click to Restart</p>
    </div>

    <script>
        // --- Configuration ---
        const CONFIG = {
            bgColor: 0xa8d8ea,
            fogColor: 0xa8d8ea,
            cameraDistance: 15,
            cameraHeight: 10,
            playerSpeed: 40,
            botSpeed: 25,
            playerDamping: 0.92,
            botDamping: 0.95,
            growthFactor: 0.05,
            foodCount: 80,
            botCount: 10,
            worldSize: 100
        };

        // --- Globals ---
        let scene, camera, renderer;
        let player, bots = [], foods = [], particles = [];
        let raycaster, mouse;
        let clock;
        let isGameActive = false;
        let audioController;
        let floorPlane;
        let gridHelper;
        let gradientTexture;
        let comets = [];
        let powerups = [];
        let cameraState = { yaw: 0, pitch: 0.5, targetYaw: 0, targetPitch: 0.5 };

        const botNames = [
            "Alpha", "Beta", "Gamma", "Delta", "Epsilon",
            "Zeta", "Eta", "Theta", "Iota", "Kappa",
            "Lambda", "Mu", "Nu", "Xi", "Omicron"
        ];

        const input = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            sprint: false,
            mouseX: 0,
            mouseY: 0,
            dash: false
        };

        // --- Classes ---
        class Blob {
            constructor(isPlayer, color, name = null) {
                this.isPlayer = isPlayer;
                this.scale = 1;
                this.score = 1.0;
                this.isDead = false;
                this.velocity = new THREE.Vector3();
                this.aiTimer = 0;
                this.aiState = 'wander';
                this.target = new THREE.Vector3();

                // Name Assignment
                if (this.isPlayer) {
                    this.name = "You";
                } else {
                    this.name = name || botNames[Math.floor(Math.random() * botNames.length)];
                }

                // Mesh
                const geometry = new THREE.IcosahedronGeometry(1, 1);
                const material = new THREE.MeshToonMaterial({
                    color: color,
                    gradientMap: gradientTexture
                });

                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.castShadow = true;
                this.mesh.receiveShadow = true;
                this.mesh.position.set(
                    (Math.random() - 0.5) * CONFIG.worldSize,
                    1,
                    (Math.random() - 0.5) * CONFIG.worldSize
                );

                // Outline
                this.outline = createOutline(geometry, 0x000000);
                this.mesh.add(this.outline);

                // Physics Body (Simple Sphere)
                this.body = new THREE.Object3D();
                this.body.add(this.mesh);
                scene.add(this.body);

                // Add ID for easy lookup
                this.mesh.userData = { parent: this };
            }

            update(delta, time) {
                if (this.isDead) return;

                if (this.isPlayer) {
                    this.updatePlayerInput(delta);
                } else {
                    this.updateAI(delta, time);
                }

                // Physics
                this.mesh.position.add(this.velocity.clone().multiplyScalar(delta));
                this.velocity.multiplyScalar(this.isPlayer ? CONFIG.playerDamping : CONFIG.botDamping);

                // Boundaries
                const dist = this.mesh.position.length();
                if (dist > CONFIG.worldSize) {
                    this.mesh.position.setLength(CONFIG.worldSize);
                }

                // Rotation
                if (this.velocity.length() > 0.1) {
                    const speed = this.velocity.length();
                    const axis = new THREE.Vector3(this.velocity.z, 0, -this.velocity.x).normalize();
                    this.body.rotateOnWorldAxis(axis, speed * delta * 0.5);
                    this.outline.rotateOnWorldAxis(axis, speed * delta * 0.5);
                }

                // Float
                this.mesh.position.y = this.scale + Math.sin(time * 2 + this.mesh.id) * 0.1;
            }

            updatePlayerInput(delta) {
                // Mouse Movement (Raycast to floor)
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(floorPlane);

                if (intersects.length > 0) {
                    const targetPoint = intersects[0].point;
                    targetPoint.y = this.mesh.position.y; // Keep height

                    const dir = new THREE.Vector3().subVectors(targetPoint, this.mesh.position);
                    const dist = dir.length();

                    if (dist > 1) {
                        // Deadzone
                        dir.normalize();

                        // Sprint Logic
                        let currentSpeed = CONFIG.playerSpeed;
                        if (input.sprint && this.scale > 1.2) {
                            currentSpeed *= 1.8; // Boost
                            this.grow(-0.2 * delta); // Burn mass

                            // Burn Particles
                            if (Math.random() < 0.3) {
                                spawnParticles(this.mesh.position, 0xffaa00, 1);
                            }
                        }

                        this.velocity.add(dir.multiplyScalar(currentSpeed * delta));
                    }
                }

                // Dash Logic
                if (input.dash && this.scale > 1.2) {
                    input.dash = false; // Consume input
                    this.dash();
                }

                // Speed Lines
                const speed = this.velocity.length();
                const speedLines = document.getElementById('speed-lines');
                if (speed > 10) {
                    speedLines.style.opacity = Math.min((speed - 10) / 20, 0.8);
                } else {
                    speedLines.style.opacity = 0;
                }
            }

            updateAI(delta, time) {
                this.aiTimer -= delta;

                // Simple State Machine
                if (this.aiTimer <= 0) {
                    this.aiTimer = 1 + Math.random() * 2;

                    // Decide state
                    // 1. Check for threats (larger blobs)
                    let threat = null;
                    let closestDist = Infinity;

                    // Check player
                    if (!player.isDead && player.scale > this.scale * 1.1) {
                        const d = this.mesh.position.distanceTo(player.mesh.position);
                        if (d < 30) {
                            threat = player;
                            closestDist = d;
                        }
                    }

                    if (threat) {
                        this.aiState = 'flee';
                        this.target = threat.mesh.position.clone();
                    } else {
                        // 2. Look for food or smaller blobs
                        let prey = null;
                        closestDist = Infinity;

                        // Check food
                        for (let food of foods) {
                            const d = this.mesh.position.distanceTo(food.position);
                            if (d < 20 && d < closestDist) {
                                prey = food;
                                closestDist = d;
                            }
                        }

                        if (prey) {
                            this.aiState = 'chase';
                            this.target = prey.position.clone();
                        } else {
                            this.aiState = 'wander';
                            const angle = Math.random() * Math.PI * 2;
                            const r = 10 + Math.random() * 20;
                            this.target.set(
                                this.mesh.position.x + Math.cos(angle) * r,
                                0,
                                this.mesh.position.z + Math.sin(angle) * r
                            );
                        }
                    }
                }

                // Execute State
                const direction = new THREE.Vector3();
                if (this.aiState === 'flee') {
                    direction.subVectors(this.mesh.position, this.target); // Run away
                } else {
                    direction.subVectors(this.target, this.mesh.position); // Run towards
                }
                direction.y = 0;
                direction.normalize();
                this.velocity.add(direction.multiplyScalar(CONFIG.botSpeed * delta));
            }

            grow(amount) {
                this.scale += amount;
                this.score = (1 + (this.scale - 1) * 10).toFixed(1);
                this.mesh.scale.setScalar(this.scale);

                if (this.isPlayer && parseFloat(this.score) >= 150) {
                    triggerWin();
                }
            }

            die() {
                this.isDead = true;
                scene.remove(this.mesh);
                spawnParticles(this.mesh.position, 0xff0000, 20); // Big explosion
            }

            dash() {
                // Cost
                this.grow(-0.5);

                // Boost
                const boostDir = this.velocity.clone().normalize();
                if (boostDir.length() === 0) boostDir.set(0, 0, 1); // Default forward if still

                this.velocity.add(boostDir.multiplyScalar(CONFIG.playerSpeed * 2));

                // Visuals
                spawnParticles(this.mesh.position, 0xffffff, 10);
                audioController.playDashSound();
            }
        }

        // --- Audio Controller ---
        class AudioController {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.3;
                this.masterGain.connect(this.ctx.destination);
                this.isPlaying = false;
            }

            async start() {
                if (this.ctx.state === 'suspended') {
                    await this.ctx.resume();
                }
                if (!this.isPlaying) {
                    this.isPlaying = true;
                    this.startMusic();
                }
            }

            startMusic() {
                // Simple chord progression: Cmaj7 - Am7 - Fmaj7 - G7
                const chords = [
                    [261.63, 329.63, 392.00, 493.88], // Cmaj7
                    [220.00, 261.63, 329.63, 392.00], // Am7
                    [174.61, 220.00, 261.63, 329.63], // Fmaj7
                    [196.00, 246.94, 293.66, 349.23]  // G7
                ];

                let chordIndex = 0;

                const playChord = () => {
                    if (!isGameActive) return;

                    const chord = chords[chordIndex];
                    chordIndex = (chordIndex + 1) % chords.length;

                    // Play each note in the chord
                    chord.forEach((freq, i) => {
                        const osc = this.ctx.createOscillator();
                        osc.type = 'sine';
                        osc.frequency.value = freq;

                        const gain = this.ctx.createGain();
                        gain.gain.setValueAtTime(0, this.ctx.currentTime);
                        gain.gain.linearRampToValueAtTime(0.02, this.ctx.currentTime + 0.1);
                        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 3.5);

                        osc.connect(gain);
                        gain.connect(this.masterGain);

                        osc.start();
                        osc.stop(this.ctx.currentTime + 4);
                    });

                    // Add a melody note occasionally
                    if (Math.random() > 0.3) {
                        this.playMelodyNote(chord);
                    }

                    setTimeout(playChord, 4000); // Change chord every 4 seconds
                };

                playChord();
            }

            playMelodyNote(chord) {
                const note = chord[Math.floor(Math.random() * chord.length)] * (Math.random() > 0.5 ? 2 : 1);
                const osc = this.ctx.createOscillator();
                osc.type = 'triangle';
                osc.frequency.value = note;

                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0.05, this.ctx.currentTime + 0.05);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1);

                osc.connect(gain);
                gain.connect(this.masterGain);

                osc.start();
                osc.stop(this.ctx.currentTime + 1);
            }

            playCollectSound() {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(523.25, this.ctx.currentTime); // C5
                osc.frequency.exponentialRampToValueAtTime(1046.50, this.ctx.currentTime + 0.1); // C6

                gain.gain.setValueAtTime(0, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0.1, this.ctx.currentTime + 0.02);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);

                osc.connect(gain);
                gain.connect(this.masterGain);

                osc.start();
                osc.stop(this.ctx.currentTime + 0.3);
            }

            playDashSound() {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(200, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(50, this.ctx.currentTime + 0.3);

                gain.gain.setValueAtTime(0, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0.1, this.ctx.currentTime + 0.05);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);

                osc.connect(gain);
                gain.connect(this.masterGain);

                osc.start();
                osc.stop(this.ctx.currentTime + 0.3);
            }
        }

        // --- Helpers ---
        function createGradientTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 4;
            canvas.height = 1;
            const context = canvas.getContext('2d');
            const gradient = context.createLinearGradient(0, 0, 4, 0);
            gradient.addColorStop(0, '#4a4a4a');
            gradient.addColorStop(0.5, '#a0a0a0');
            gradient.addColorStop(1, '#ffffff');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 4, 1);

            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            return texture;
        }

        function createOutline(geometry, color, scale = 1.05) {
            const outlineMaterial = new THREE.MeshBasicMaterial({
                color: color,
                side: THREE.BackSide
            });
            const outlineMesh = new THREE.Mesh(geometry, outlineMaterial);
            outlineMesh.scale.multiplyScalar(scale);
            return outlineMesh;
        }

        // --- Initialization ---
        function init() {
            // Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.bgColor);
            scene.fog = new THREE.Fog(CONFIG.bgColor, 30, 100);

            // Camera Setup
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            // Initial pos
            camera.position.set(0, CONFIG.cameraHeight, CONFIG.cameraDistance);

            // Renderer Setup
            renderer = new THREE.WebGLRenderer({
                antialias: true, alpha: false
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
            dirLight.position.set(30, 50, 30);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 150;
            const d = 80;
            dirLight.shadow.camera.left = -d;
            dirLight.shadow.camera.right = d;
            dirLight.shadow.camera.top = d;
            dirLight.shadow.camera.bottom = -d;
            scene.add(dirLight);

            // Textures
            gradientTexture = createGradientTexture();

            // Ground
            const planeGeometry = new THREE.PlaneGeometry(CONFIG.worldSize * 2, CONFIG.worldSize * 2, 32, 32);

            // Uneven terrain
            const posAttribute = planeGeometry.attributes.position;
            for (let i = 0; i < posAttribute.count; i++) {
                const x = posAttribute.getX(i);
                const y = posAttribute.getY(i);
                const z = posAttribute.getZ(i);
                // Add some noise
                const height = Math.sin(x * 0.1) * Math.cos(y * 0.1) * 2;
                posAttribute.setZ(i, z + height);
            }
            planeGeometry.computeVertexNormals();

            const planeMaterial = new THREE.MeshToonMaterial({
                color: 0x88cc88,
                gradientMap: gradientTexture
            });
            floorPlane = new THREE.Mesh(planeGeometry, planeMaterial);
            floorPlane.rotation.x = -Math.PI / 2;
            floorPlane.receiveShadow = true;
            scene.add(floorPlane);

            // Grid
            gridHelper = new THREE.GridHelper(CONFIG.worldSize * 2, 50, 0xffffff, 0xffffff);
            gridHelper.material.opacity = 0.3;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);

            // Player Setup
            player = new Blob(true, 0xff6b6b);

            // Bots Setup
            for (let i = 0; i < CONFIG.botCount; i++) {
                // Random pastel color
                const hue = Math.random();
                const color = new THREE.Color().setHSL(hue, 0.7, 0.6);
                const bot = new Blob(false, color);
                bots.push(bot);
            }

            // Food
            initFood();

            // Input Setup
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            window.addEventListener('resize', onWindowResize, false);

            // Mouse Move (Track position for Raycast)
            document.addEventListener('mousemove', (e) => {
                // Normalize mouse coordinates
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            }, false);

            document.addEventListener('mousedown', () => input.sprint = true);
            document.addEventListener('mouseup', () => input.sprint = false);

            // WASD (Camera Control)
            document.addEventListener('keydown', (e) => {
                switch (e.code) {
                    case 'KeyW': input.forward = true; break;
                    case 'KeyS': input.backward = true; break;
                    case 'KeyA': input.left = true; break;
                    case 'KeyD': input.right = true; break;
                    case 'Space': input.dash = true; break;
                }
            });

            document.addEventListener('keyup', (e) => {
                switch (e.code) {
                    case 'KeyW': input.forward = false; break;
                    case 'KeyS': input.backward = false; break;
                    case 'KeyA': input.left = false; break;
                    case 'KeyD': input.right = false; break;
                }
            });

            clock = new THREE.Clock();
            audioController = new AudioController();

            // UI Listeners
            const startOverlay = document.getElementById('start-overlay');
            startOverlay.addEventListener('click', () => {
                startOverlay.style.opacity = 0;
                setTimeout(() => startOverlay.remove(), 500);
                audioController.start();
                isGameActive = true;
                // No pointer lock
            });

            const gameOverOverlay = document.getElementById('game-over-overlay');
            gameOverOverlay.addEventListener('click', () => {
                location.reload();
            });

            // Remove Loading
            const loading = document.getElementById('loading');
            if (loading) {
                loading.style.opacity = 0;
                setTimeout(() => loading.remove(), 500);
            }

            animate();
        }

        function updateCamera() {
            // WASD Camera Control
            const camSpeed = 0.03;
            if (input.left) cameraState.targetYaw += camSpeed;
            if (input.right) cameraState.targetYaw -= camSpeed;
            if (input.forward) cameraState.targetPitch += camSpeed; // Inverted: W = Pitch Up (Look Down)
            if (input.backward) cameraState.targetPitch -= camSpeed; // Inverted: S = Pitch Down (Look Up)

            // Clamp pitch
            cameraState.targetPitch = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, cameraState.targetPitch));

            // Smoothly interpolate rotation
            cameraState.yaw += (cameraState.targetYaw - cameraState.yaw) * 0.1;
            cameraState.pitch += (cameraState.targetPitch - cameraState.pitch) * 0.1;

            // Calculate offset based on pitch/yaw
            const dist = CONFIG.cameraDistance + (player.scale * 3);
            const height = CONFIG.cameraHeight + (player.scale * 3);

            // Orbit logic
            const hDist = dist * Math.cos(cameraState.pitch);
            const vDist = dist * Math.sin(cameraState.pitch);

            const offsetX = Math.sin(cameraState.yaw) * hDist;
            const offsetZ = Math.cos(cameraState.yaw) * hDist;

            const targetPos = player.mesh.position.clone();
            targetPos.x += offsetX;
            targetPos.z += offsetZ;
            targetPos.y += vDist;

            camera.position.lerp(targetPos, 0.1);
            camera.lookAt(player.mesh.position);
        }

        function initFood() {
            const geometry = new THREE.IcosahedronGeometry(0.5, 0);
            const material = new THREE.MeshToonMaterial({
                color: 0xffd93d,
                gradientMap: gradientTexture
            });
            const outlineGeo = new THREE.IcosahedronGeometry(0.5, 0);

            for (let i = 0; i < CONFIG.foodCount; i++) {
                spawnFood(geometry, material, outlineGeo);
            }
        }

        function spawnFood(geometry, material, outlineGeo) {
            const group = new THREE.Group();
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            const outline = createOutline(outlineGeo, 0x000000, 1.05);
            group.add(mesh);
            group.add(outline);

            // Random position
            const angle = Math.random() * Math.PI * 2;
            const radius = 10 + Math.random() * (CONFIG.worldSize - 10);
            group.position.set(Math.cos(angle) * radius, 0.5, Math.sin(angle) * radius);

            group.userData = {
                floatSpeed: 1 + Math.random(),
                floatOffset: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 2,
                baseY: 0.5,
                geometry: geometry, // Store for respawn
                material: material,
                outlineGeo: outlineGeo
            };

            scene.add(group);
            foods.push(group);
        }

        function spawnParticles(position, color) {
            const particleCount = 8;
            const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            const mat = new THREE.MeshBasicMaterial({ color: color });

            for (let i = 0; i < particleCount; i++) {
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(position);
                mesh.position.x += (Math.random() - 0.5);
                mesh.position.z += (Math.random() - 0.5);
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 5,
                    Math.random() * 5 + 2,
                    (Math.random() - 0.5) * 5
                );
                particles.push({ mesh: mesh, velocity: velocity, life: 1.0 });
                scene.add(mesh);
            }
        }

        function updateParticles(delta) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.life -= delta * 2; // Fade out speed

                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    particles.splice(i, 1);
                    continue;
                }

                p.velocity.y -= 9.8 * delta; // Gravity
                p.mesh.position.add(p.velocity.clone().multiplyScalar(delta));
                p.mesh.rotation.x += delta * 5;
                p.mesh.rotation.z += delta * 5;
                p.mesh.scale.setScalar(p.life);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateLeaderboard() {
            // Combine player and bots
            const allBlobs = [player, ...bots].filter(b => !b.isDead);

            // Sort by score (descending)
            allBlobs.sort((a, b) => parseFloat(b.score) - parseFloat(a.score));

            // Update UI
            const list = document.getElementById('leaderboard-list');
            if (list) {
                list.innerHTML = '';
                allBlobs.forEach((blob, index) => {
                    const li = document.createElement('li');
                    li.innerHTML = `<span>${index + 1}. ${blob.name}</span><span>${blob.score}</span>`;
                    if (blob.isPlayer) li.classList.add('player');
                    list.appendChild(li);
                });
            }
        }

        function updateGameLogic(delta, time) {
            updateLeaderboard();

            // Update Player
            if (!player.isDead) {
                player.update(delta, time);
                updateCamera();

                // UI
                document.getElementById('score').innerText = player.score;
                document.getElementById('alive-count').innerText = bots.filter(b => !b.isDead).length + 1;
            }

            // Update Bots
            for (let bot of bots) {
                bot.update(delta, time);
            }

            // Combat Logic (Blob vs Blob)
            const allBlobs = [player, ...bots].filter(b => !b.isDead);
            for (let i = 0; i < allBlobs.length; i++) {
                for (let j = i + 1; j < allBlobs.length; j++) {
                    const a = allBlobs[i];
                    const b = allBlobs[j];
                    const dist = a.mesh.position.distanceTo(b.mesh.position);
                    const minDist = a.scale + b.scale;

                    if (dist < minDist * 0.8) {
                        if (a.scale > b.scale * 1.2) {
                            eatBlob(a, b);
                        } else if (b.scale > a.scale * 1.2) {
                            eatBlob(b, a);
                        }
                    }
                }
            }

            // Comet Logic
            if (Math.random() < 0.003) { // Increased spawn rate
                spawnComet();
            }
            updateComets(delta);

            // Powerup Logic
            if (Math.random() < 0.002) {
                spawnPowerup();
            }
            updatePowerups(delta, time);

            // Update Food
            for (let i = foods.length - 1; i >= 0; i--) {
                const group = foods[i];
                group.position.y = group.userData.baseY + Math.sin(time * group.userData.floatSpeed + group.userData.floatOffset) * 0.3;
                group.rotation.y += group.userData.rotationSpeed * delta;

                // Check collisions with all blobs
                // Player
                if (!player.isDead) {
                    const dist = player.mesh.position.distanceTo(group.position);

                    // Magnet Effect
                    if (player.hasMagnet && dist < 15) {
                        const dir = new THREE.Vector3().subVectors(player.mesh.position, group.position).normalize();
                        group.position.add(dir.multiplyScalar(delta * 10));
                    }

                    if (dist < player.scale + 0.5) {
                        collectFood(player, group, i);
                        continue;
                    }
                }

                // Bots
                for (let bot of bots) {
                    if (bot.isDead) continue;
                    const dist = bot.mesh.position.distanceTo(group.position);
                    if (dist < bot.scale + 0.5) {
                        collectFood(bot, group, i);
                        break;
                    }
                }
            }
        }

        function spawnPowerup() {
            const type = Math.random() > 0.5 ? 'speed' : 'magnet';
            const color = type === 'speed' ? 0x00ffff : 0x9900ff;
            const geometry = type === 'speed' ? new THREE.BoxGeometry(1, 1, 1) : new THREE.ConeGeometry(0.7, 1.5, 4);

            const material = new THREE.MeshToonMaterial({
                color: color,
                gradientMap: gradientTexture
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;

            // Outline
            const outlineGeo = type === 'speed' ? new THREE.BoxGeometry(1, 1, 1) : new THREE.ConeGeometry(0.7, 1.5, 4);
            const outline = createOutline(outlineGeo, 0x000000, 1.1);
            mesh.add(outline);

            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * (CONFIG.worldSize - 10);
            mesh.position.set(Math.cos(angle) * radius, 1, Math.sin(angle) * radius);

            mesh.userData = { type: type };
            scene.add(mesh);
            powerups.push(mesh);
        }

        function updatePowerups(delta, time) {
            for (let i = powerups.length - 1; i >= 0; i--) {
                const p = powerups[i];
                p.rotation.y += delta;
                p.position.y = 1 + Math.sin(time * 3) * 0.3;

                if (!player.isDead) {
                    const dist = player.mesh.position.distanceTo(p.position);
                    if (dist < player.scale + 1) {
                        activatePowerup(p.userData.type);
                        scene.remove(p);
                        powerups.splice(i, 1);
                        spawnParticles(p.position, p.material.color.getHex(), 15);
                        audioController.playCollectSound(); // Reuse for now
                    }
                }
            }
        }

        function activatePowerup(type) {
            const ui = document.getElementById('ui-layer');
            const msg = document.createElement('p');
            msg.style.color = type === 'speed' ? '#00ffff' : '#9900ff';
            msg.innerText = type.toUpperCase() + " ACTIVATED!";
            ui.appendChild(msg);
            setTimeout(() => msg.remove(), 2000);

            if (type === 'speed') {
                const originalSpeed = CONFIG.playerSpeed;
                CONFIG.playerSpeed *= 2;
                setTimeout(() => CONFIG.playerSpeed = originalSpeed, 5000);
            } else if (type === 'magnet') {
                player.hasMagnet = true;
                setTimeout(() => player.hasMagnet = false, 8000);
            }
        }

        function eatBlob(predator, prey) {
            if (prey.isDead) return;

            prey.die();
            predator.grow(prey.scale * 0.5); // Gain half of prey's mass

            if (prey.isPlayer) {
                triggerGameOver();
            } else if (predator.isPlayer) {
                audioController.playCollectSound(); // Maybe a deeper sound later
                // Check win condition
                const remainingBots = bots.filter(b => !b.isDead).length;
                if (remainingBots === 0) {
                    triggerWin();
                }
            }
        }

        function triggerGameOver() {
            document.getElementById('game-over-overlay').style.display = 'flex';
            document.getElementById('game-over-title').innerText = "GAME OVER";
        }

        function triggerWin() {
            document.getElementById('game-over-overlay').style.display = 'flex';
            document.getElementById('game-over-title').innerText = "YOU WIN!";
            document.getElementById('game-over-title').style.color = "#4cd137";
        }

        // --- Comet System ---
        function spawnComet() {
            const geometry = new THREE.IcosahedronGeometry(2, 1); // Jagged
            const material = new THREE.MeshStandardMaterial({
                color: 0xff4400,
                emissive: 0xff2200,
                roughness: 0.8,
                flatShading: true
            });
            const mesh = new THREE.Mesh(geometry, material);

            // Light
            const light = new THREE.PointLight(0xffaa00, 1, 30);
            mesh.add(light);

            // Start high up
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * (CONFIG.worldSize - 20);
            const targetX = Math.cos(angle) * radius;
            const targetZ = Math.sin(angle) * radius;

            mesh.position.set(targetX, 100, targetZ);

            const target = new THREE.Vector3(targetX, 0, targetZ);
            const velocity = new THREE.Vector3().subVectors(target, mesh.position).normalize().multiplyScalar(40); // Fast

            scene.add(mesh);
            comets.push({ mesh, velocity, target });
        }

        function updateComets(delta) {
            for (let i = comets.length - 1; i >= 0; i--) {
                const c = comets[i];
                c.mesh.position.add(c.velocity.clone().multiplyScalar(delta));
                c.mesh.rotation.x += delta;
                c.mesh.rotation.y += delta;

                // Trail
                if (Math.random() < 0.3) {
                    spawnParticles(c.mesh.position, 0xff4400, 1);
                }

                // Check impact
                if (c.mesh.position.y <= 0.5) {
                    // Boom
                    spawnParticles(c.mesh.position, 0xff4400, 30);

                    // Create Crater
                    const impactPos = c.mesh.position;
                    const craterRadius = 8;
                    const positions = floorPlane.geometry.attributes.position;
                    const v3 = new THREE.Vector3();

                    for (let k = 0; k < positions.count; k++) {
                        v3.fromBufferAttribute(positions, k);
                        // Local (x, y, z) -> World (x, z, -y) roughly?
                        // Easier: just distance check on X/Y of plane geometry vs X/Z of impact
                        const dx = v3.x - impactPos.x;
                        const dy = v3.y - impactPos.z; // Plane Y maps to World Z
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < craterRadius) {
                            const depth = (1 - dist / craterRadius) * 3;
                            let z = positions.getZ(k);
                            z -= depth; // Lower the ground
                            positions.setZ(k, z);
                        }
                    }
                    positions.needsUpdate = true;
                    floorPlane.geometry.computeVertexNormals();

                    scene.remove(c.mesh);
                    comets.splice(i, 1);
                }
            }
        }

        function collectFood(blob, group, index) {
            if (blob.isPlayer) audioController.playCollectSound();
            spawnParticles(group.position, 0xffd93d, 5);
            scene.remove(group);
            foods.splice(index, 1);
            blob.grow(CONFIG.growthFactor);
            spawnFood(group.userData.geometry, group.userData.material, group.userData.outlineGeo);
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            if (isGameActive) {
                updateGameLogic(delta, time);
                updateParticles(delta);
            }

            renderer.render(scene, camera);
        }

        window.onload = init;
    </script>
</body>

</html>